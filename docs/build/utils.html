<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <title>Utilities // Werkzeug Documentation</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="style.css">
  <link rel="stylesheet" type="text/css" href="pygments.css">
  <link rel="stylesheet" type="text/css" media="print" href="print.css">
  <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <div class="page">
    <div class="header">
      <h1><a href="index.html"><span>Werkzeug</span></a></h1>
      <p><span>The Swiss Army Knife For Python Web Developers</span></p>
    </div>
    <div class="body">
      <h2>Utilities</h2>
      
      <div class="toc">
        <h4>Table of Contents</h4>
        <ul><li><a class="reference" href="#data-structures" id="id1" name="id1">Data Structures</a></li>
<li><a class="reference" href="#working-with-http-headers" id="id2" name="id2">Working with HTTP Headers</a></li>
<li><a class="reference" href="#url-helpers" id="id3" name="id3">URL Helpers</a></li>
<li><a class="reference" href="#html-helpers" id="id4" name="id4">HTML Helpers</a></li>
<li><a class="reference" href="#wsgi-helpers" id="id5" name="id5">WSGI Helpers</a></li>
<li><a class="reference" href="#helper-functions" id="id6" name="id6">Helper Functions</a></li>
</ul>
      </div>
      
      <p>Werkzeug comes with a bunch of utilties that can be useful for WSGI
applications.  Most of the classes provided by this module are used by the
wrappers, you can however use them without the wrappers, too.</p>
<p>All the utilities can be directly imported from the <cite>werkzeug</cite> module.</p>
<div class="section">
<h3 id="data-structures">Data Structures</h3>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.utils.MultiDict">MultiDict</cite></dt>
<dd><p class="first">A <cite>MultiDict</cite> is a dictionary subclass customized to deal with multiple
values for the same key which is for example used by the parsing functions
in the wrappers.  This is necessary because some HTML form elements pass
multiple values for the same key.</p>
<p><cite>MultiDict</cite> implements the all standard dictionary methods.  Internally,
it saves all values for a key as a list, but the standard dict access
methods will only return the first value for a key. If you want to gain
access to the other values too you have to use the <cite>list</cite> methods as
explained below.</p>
<p>Basic Usage:</p>
<div class="syntax"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">MultiDict</span><span class="p">([(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">MultiDict([(&#39;a&#39;, &#39;b&#39;), (&#39;a&#39;, &#39;c&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">getlist</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
<span class="go">[&#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">d</span>
<span class="go">True</span>
</pre></div>
<p>It behaves like a normal dict thus all dict functions will only return the
first value when multiple values for one key are found.</p>
<p>The following additional methods exist that are used to get or set the
other values for a key or convert:</p>
<dl>
<dt><cite id="werkzeug.utils.MultiDict.get">get</cite> <tt class="func-signature docutils literal"><span class="pre">(key,</span> <span class="pre">default=None,</span> <span class="pre">type=None)</span></tt></dt>
<dd><p class="first">Return the default value if the requested data doesn&#8217;t exist.
If <cite>type</cite> is provided and is a callable it should convert the value,
return it or raise a <cite>ValueError</cite> if that is not possible.  In this
case the function will return the default as if the value was not
found.</p>
<p>Example:</p>
<div class="syntax"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">MultiDict</span><span class="p">(</span><span class="n">foo</span><span class="o">=</span><span class="s">&#39;42&#39;</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="s">&#39;blub&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;bar&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">-1</span>
</pre></div>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.MultiDict.getlist">getlist</cite> <tt class="func-signature docutils literal"><span class="pre">(key,</span> <span class="pre">type=None)</span></tt></dt>
<dd><p class="first">Return the list of items for a given key. If that key is not in the
<cite>MultiDict</cite>, the return value will be an empty list.  Just as <cite>get</cite>
<cite>getlist</cite> accepts a <cite>type</cite> parameter.  All items will be converted
with the callable defined there.</p>
<p class="last"><strong>returns</strong>: list</p>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.MultiDict.setlist">setlist</cite> <tt class="func-signature docutils literal"><span class="pre">(key,</span> <span class="pre">new_list)</span></tt></dt>
<dd><p class="first">Remove the old values for a key and add new ones.  Note that the list
you pass the values in will be shallow-copied before it is inserted in
the dictionary.</p>
<div class="syntax"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">multidict</span><span class="o">.</span><span class="n">setlist</span><span class="p">(</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">multidict</span><span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">]</span>
<span class="go">&#39;1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">multidict</span><span class="o">.</span><span class="n">getlist</span><span class="p">(</span><span class="s">&#39;foo&#39;</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;]</span>
</pre></div>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.MultiDict.setlistdefault">setlistdefault</cite> <tt class="func-signature docutils literal"><span class="pre">(key,</span> <span class="pre">default_list=())</span></tt></dt>
<dd>Like <cite>setdefault</cite> but sets multiple values.</dd>
</dl>
<p>These functions work like the functions with the same name without
list.  Unlike the regular dict functions those operate on all the
values as lists, not only on the first one:</p>
<p><cite>lists</cite>, <cite>listvalues</cite>, <cite>iterlists</cite>, <cite>iterlistvalues</cite>, <cite>poplist</cite>,
and <cite>popitemlist</cite>.</p>
<p class="last">Also notable: <cite>update</cite> adds values and does not replace existing ones.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.utils.CombinedMultiDict">CombinedMultiDict</cite></dt>
<dd><p class="first">A read only <cite>MultiDict</cite> decorator that you can pass multiple <cite>MultiDict</cite>
instances as sequence and it will combine the return values of all wrapped
dicts:</p>
<div class="syntax"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">werkzeug</span> <span class="k">import</span> <span class="n">MultiDict</span><span class="p">,</span> <span class="n">CombinedMultiDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">post</span> <span class="o">=</span> <span class="n">MultiDict</span><span class="p">([(</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="s">&#39;bar&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get</span> <span class="o">=</span> <span class="n">MultiDict</span><span class="p">([(</span><span class="s">&#39;blub&#39;</span><span class="p">,</span> <span class="s">&#39;blah&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">combined</span> <span class="o">=</span> <span class="n">CombinedMultiDict</span><span class="p">([</span><span class="n">get</span><span class="p">,</span> <span class="n">post</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">combined</span><span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">]</span>
<span class="go">&#39;bar&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">combined</span><span class="p">[</span><span class="s">&#39;blub&#39;</span><span class="p">]</span>
<span class="go">&#39;blah&#39;</span>
</pre></div>
<p class="last">This works for all read operations and will raise a <cite>TypeError</cite> for
methods that usually change data which isn&#8217;t possible.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.utils.Headers">Headers</cite></dt>
<dd><p class="first">An object that stores some headers.  It has a dict like interface
but is ordered and can store keys multiple times.</p>
<p>This data structure is useful if you want a nicer way to handle WSGI
headers which are stored as tuples in a list.</p>
<dl>
<dt><cite id="werkzeug.utils.Headers.__init__">__init__</cite> <tt class="func-signature docutils literal"><span class="pre">(defaults=None,</span> <span class="pre">_list=None)</span></tt></dt>
<dd>Create a new <cite>Headers</cite> object based on a list or dict of headers which
are used as default values.  This does not reuse the list passed to
the constructor for internal usage.  To create a <cite>Headers</cite> object that
uses as internal storage the list or list-like object provided it&#8217;s
possible to use the <cite>linked</cite> classmethod.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.Headers.linked">linked</cite> <tt class="func-signature docutils literal"><span class="pre">(headerlist)</span></tt></dt>
<dd><p class="first">Create a new <cite>Headers</cite> object that uses the list of headers passed as
internal storage:</p>
<div class="syntax"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">headerlist</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;Content-Length&#39;</span><span class="p">,</span> <span class="s">&#39;40&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">headers</span> <span class="o">=</span> <span class="n">Headers</span><span class="o">.</span><span class="n">linked</span><span class="p">(</span><span class="n">headerlist</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">headers</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="s">&#39;text/html&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">headerlist</span>
<span class="go">[(&#39;Content-Length&#39;, &#39;40&#39;), (&#39;Content-Type&#39;, &#39;text/html&#39;)]</span>
</pre></div>
<p class="last"><strong>returns</strong>: new linked <cite>Headers</cite> object.</p>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.Headers.get">get</cite> <tt class="func-signature docutils literal"><span class="pre">(key,</span> <span class="pre">default=None,</span> <span class="pre">type=None)</span></tt></dt>
<dd><p class="first">Return the default value if the requested data doesn&#8217;t exist.
If <cite>type</cite> is provided and is a callable it should convert the value,
return it or raise a <cite>ValueError</cite> if that is not possible.  In this
case the function will return the default as if the value was not
found.</p>
<p>Example:</p>
<div class="syntax"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Headers</span><span class="p">([(</span><span class="s">&#39;Content-Length&#39;</span><span class="p">,</span> <span class="s">&#39;42&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Content-Length&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">42</span>
</pre></div>
<p class="last">If a headers object is bound you must notadd unicode strings
because no encoding takes place.</p>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.Headers.getlist">getlist</cite> <tt class="func-signature docutils literal"><span class="pre">(key,</span> <span class="pre">type=None)</span></tt></dt>
<dd><p class="first">Return the list of items for a given key. If that key is not in the
<cite>MultiDict</cite>, the return value will be an empty list.  Just as <cite>get</cite>
<cite>getlist</cite> accepts a <cite>type</cite> parameter.  All items will be converted
with the callable defined there.</p>
<p class="last"><strong>returns</strong>: list</p>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.Headers.add">add</cite> <tt class="func-signature docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></tt></dt>
<dd>add a new header tuple to the list</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.Headers.set">set</cite> <tt class="func-signature docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></tt></dt>
<dd>remove all header tuples for key and add
a new one</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.Headers.extend">extend</cite> <tt class="func-signature docutils literal"><span class="pre">(iterable)</span></tt></dt>
<dd>Extend the headers with a dict or an iterable yielding keys and
values.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.Headers.clear">clear</cite> <tt class="func-signature docutils literal"><span class="pre">()</span></tt></dt>
<dd>clears all headers</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.Headers.to_list">to_list</cite> <tt class="func-signature docutils literal"><span class="pre">(charset='utf-8')</span></tt></dt>
<dd><p class="first">Convert the headers into a list and converts the unicode header items
to the specified charset.</p>
<p class="last"><strong>returns</strong>: list</p>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.Headers.__contains__">__contains__</cite> <tt class="func-signature docutils literal"><span class="pre">(key)</span></tt></dt>
<dd>Check if a key is present.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.Headers.__iter__">__iter__</cite> <tt class="func-signature docutils literal"><span class="pre">()</span></tt></dt>
<dd>Yield <tt class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></tt> tuples.</dd>
</dl>
<p class="last">All the other dict functions such as <cite>iterkeys</cite> are available and
work the same.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.utils.EnvironHeaders">EnvironHeaders</cite></dt>
<dd>Read only version of the headers from a WSGI environment.  This
provides the same interface as <cite>Headers</cite> and is constructed from
a WSGI environment.</dd>
</dl>
</div>
<div class="section">
<h3 id="working-with-http-headers">Working with HTTP Headers</h3>
<dl>
<dt><cite id="werkzeug.http.parse_set_header">parse_set_header</cite> <tt class="func-signature docutils literal"><span class="pre">(value,</span> <span class="pre">on_update=None)</span></tt></dt>
<dd>Parse a set like header and return a <cite>HeaderSet</cite> object.  The return
value is an object that treats the items case insensitive and keeps the
order of the items.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.parse_list_header">parse_list_header</cite> <tt class="func-signature docutils literal"><span class="pre">(value)</span></tt></dt>
<dd><p class="first">Parse lists as described by RFC 2068 Section 2.</p>
<p class="last">In particular, parse comma-separated lists where the elements of
the list may include quoted-strings.  A quoted-string could
contain a comma.  A non-quoted string could have quotes in the
middle.  Quotes are removed automatically after parsing.</p>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.parse_dict_header">parse_dict_header</cite> <tt class="func-signature docutils literal"><span class="pre">(value)</span></tt></dt>
<dd>Parse lists of key, value paits as described by RFC 2068 Section 2 and
convert them into a python dict.  If there is no value for a key it will
be <cite>None</cite>.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.dump_header">dump_header</cite> <tt class="func-signature docutils literal"><span class="pre">(iterable)</span></tt></dt>
<dd>Dump an HTTP header again.  This is the reversal of <cite>parse_list_header</cite>,
<cite>parse_set_header</cite> and <cite>parse_dict_header</cite>.  This also quotes strings
that include an equals sign unless you pass it as dict of key, value
pairs.</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.http.Accept">Accept</cite></dt>
<dd><p class="first">An <cite>Accept</cite> object is just a list subclass for lists of
<tt class="docutils literal"><span class="pre">(value,</span> <span class="pre">quality)</span></tt> tuples.  It is automatically sorted by quality.</p>
<dl>
<dt><cite>provided</cite></dt>
<dd><cite>True</cite> if the <cite>Accept</cite> object was created from a list, <cite>False</cite> if the
initial value was <cite>None</cite>.  This is used by the request wrappers to
keep the information if the header was present or not.</dd>
<dt><cite>best</cite></dt>
<dd>The best value (does not return a tuple!).</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.Accept.__getitem__">__getitem__</cite> <tt class="func-signature docutils literal"><span class="pre">(key)</span></tt></dt>
<dd>Beside index lookup (getting item n) you can also pass it a string to
get the quality for the item.  If the item is not in the list, the
returned quality is <tt class="docutils literal"><span class="pre">0</span></tt>.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.Accept.find">find</cite> <tt class="func-signature docutils literal"><span class="pre">(key)</span></tt></dt>
<dd>Get the position of an entry or return -1</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.Accept.values">values</cite> <tt class="func-signature docutils literal"><span class="pre">()</span></tt></dt>
<dd>Return a list of the values, not the qualities.</dd>
</dl>
<dl class="last">
<dt><cite id="werkzeug.http.Accept.itervalues">itervalues</cite> <tt class="func-signature docutils literal"><span class="pre">()</span></tt></dt>
<dd>Iterate over all values.</dd>
</dl>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.parse_accept_header">parse_accept_header</cite> <tt class="func-signature docutils literal"><span class="pre">(value)</span></tt></dt>
<dd><p class="first">Parses an HTTP Accept-* header.  This does not implement a complete valid
algorithm but one that supports at least value and quality extraction.</p>
<p class="last">Returns a new <cite>Accept</cite> object (basicly a list of <tt class="docutils literal"><span class="pre">(value,</span> <span class="pre">quality)</span></tt>
tuples sorted by the quality with some additional accessor methods)</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.http.CacheControl">CacheControl</cite></dt>
<dd><p class="first">Subclass of a dict that stores values for a Cache-Control header.  It has
accesors for all the cache-control directives specified in RFC 2616.  The
class does not differentiate between request and response directives.</p>
<p>Because the cache-control directives in the HTTP header use dashes the
python descriptors use underscores for that.</p>
<p>To get a header of the <cite>CacheControl</cite> object again you can convert the
object into a string or call the <cite>to_header()</cite> function.  If you plan
to subclass it and add your own items have a look at the sourcecode for
that class.</p>
<p>The following attributes are exposed:</p>
<p class="last"><cite>no_cache</cite>, <cite>no_store</cite>, <cite>max_age</cite>, <cite>max_stale</cite>, <cite>min_fresh</cite>,
<cite>no_transform</cite>, <cite>only_if_cached</cite>, <cite>public</cite>, <cite>private</cite>, <cite>must_revalidate</cite>,
<cite>proxy_revalidate</cite>, and <cite>s_maxage</cite></p>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.parse_cache_control_header">parse_cache_control_header</cite> <tt class="func-signature docutils literal"><span class="pre">(value,</span> <span class="pre">on_update=None)</span></tt></dt>
<dd>Parse a cache control header.  The RFC differs between response and
request cache control, this method does not.  It&#8217;s your responsibility
to not use the wrong control statements.</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.http.HeaderSet">HeaderSet</cite></dt>
<dd><p class="first">Similar to the <cite>ETags</cite> class this implements a set like structure.
Unlike <cite>ETags</cite> this is case insensitive and used for vary, allow, and
content-language headers.</p>
<p>If not constructed using the <cite>parse_set_header</cite> function the instanciation
works like this:</p>
<div class="syntax"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">hs</span> <span class="o">=</span> <span class="n">HeaderSet</span><span class="p">([</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="s">&#39;bar&#39;</span><span class="p">,</span> <span class="s">&#39;baz&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hs</span>
<span class="go">HeaderSet([&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;])</span>
</pre></div>
<dl>
<dt><cite id="werkzeug.http.HeaderSet.add">add</cite> <tt class="func-signature docutils literal"><span class="pre">(header)</span></tt></dt>
<dd>Add a new header to the set.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.HeaderSet.remove">remove</cite> <tt class="func-signature docutils literal"><span class="pre">(header)</span></tt></dt>
<dd>Remove a layer from the set.  This raises an <cite>IndexError</cite> if the
header is not in the set.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.HeaderSet.update">update</cite> <tt class="func-signature docutils literal"><span class="pre">(iterable)</span></tt></dt>
<dd>Add all the headers from the iterable to the set.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.HeaderSet.discard">discard</cite> <tt class="func-signature docutils literal"><span class="pre">(header)</span></tt></dt>
<dd>Like remove but ignores errors.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.HeaderSet.find">find</cite> <tt class="func-signature docutils literal"><span class="pre">(header)</span></tt></dt>
<dd>Return the index of the header in the set or return -1 if not found.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.HeaderSet.index">index</cite> <tt class="func-signature docutils literal"><span class="pre">(header)</span></tt></dt>
<dd>Return the index of the headerin the set or raise an <cite>IndexError</cite>.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.HeaderSet.clear">clear</cite> <tt class="func-signature docutils literal"><span class="pre">()</span></tt></dt>
<dd>Clear the set.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.HeaderSet.as_set">as_set</cite> <tt class="func-signature docutils literal"><span class="pre">(preserve_casing=False)</span></tt></dt>
<dd><p class="first">Return the set as real python set structure.  When calling this all
the items are converted to lowercase and the ordering is lost.</p>
<p class="last">If <cite>preserve_casing</cite> is <cite>True</cite> the items in the set returned will
have the original case like in the <cite>HeaderSet</cite>, otherwise they will
be lowercase.</p>
</dd>
</dl>
<dl class="last">
<dt><cite id="werkzeug.http.HeaderSet.to_header">to_header</cite> <tt class="func-signature docutils literal"><span class="pre">()</span></tt></dt>
<dd>Convert the header set into an HTTP header string.</dd>
</dl>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.parse_set_header">parse_set_header</cite> <tt class="func-signature docutils literal"><span class="pre">(value,</span> <span class="pre">on_update=None)</span></tt></dt>
<dd>Parse a set like header and return a <cite>HeaderSet</cite> object.  The return
value is an object that treats the items case insensitive and keeps the
order of the items.</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.useragents.UserAgent">UserAgent</cite></dt>
<dd><p class="first">Represents a user agent.  Pass it a WSGI environment or an user agent
string and you can inspect some of the details from the user agent
string via the attributes.  The following attribute exist:</p>
<ul class="last simple">
<li><cite>string</cite>, the raw user agent string</li>
<li><cite>platform</cite>, the browser platform</li>
<li><cite>browser</cite>, the name of the browser</li>
<li><cite>version</cite>, the version of the browser</li>
<li><cite>language</cite>, the language of the browser</li>
</ul>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.parse_date">parse_date</cite> <tt class="func-signature docutils literal"><span class="pre">(value)</span></tt></dt>
<dd><p class="first">Parse one of the following date formats into a datetime object:</p>
<div class="syntax"><pre>Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
Sun Nov  6 08:49:37 1994       ; ANSI C&#39;s asctime() format
</pre></div>
<p class="last">If parsing fails the return value is <cite>None</cite>.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.http.ETags">ETags</cite></dt>
<dd><p class="first">A set that can be used to check if one etag is present in a collection
of etags.</p>
<dl>
<dt><cite id="werkzeug.http.ETags.is_weak">is_weak</cite> <tt class="func-signature docutils literal"><span class="pre">(etag)</span></tt></dt>
<dd>Check if an etag is weak.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.ETags.contains_weak">contains_weak</cite> <tt class="func-signature docutils literal"><span class="pre">(etag)</span></tt></dt>
<dd>Check if an etag is part of the set including weak and strong tags.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.ETags.contains">contains</cite> <tt class="func-signature docutils literal"><span class="pre">(etag)</span></tt></dt>
<dd>Check if an etag is part of the set ignoring weak tags.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.ETags.contains_raw">contains_raw</cite> <tt class="func-signature docutils literal"><span class="pre">(etag)</span></tt></dt>
<dd>When passed a quoted tag it will check if this tag is part of the set.
If the tag is weak it is checked against weak and strong tags, otherwise
weak only.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.ETags.as_set">as_set</cite> <tt class="func-signature docutils literal"><span class="pre">(include_weak=False)</span></tt></dt>
<dd>Convert the <cite>ETags</cite> object into a python set.  Per default all the
weak etags are not part of this set.</dd>
</dl>
<dl class="last">
<dt><cite id="werkzeug.http.ETags.to_header">to_header</cite> <tt class="func-signature docutils literal"><span class="pre">()</span></tt></dt>
<dd>Convert the etags set into a HTTP header string.</dd>
</dl>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.parse_etags">parse_etags</cite> <tt class="func-signature docutils literal"><span class="pre">(value)</span></tt></dt>
<dd>Parse and etag header.  Returns an <cite>ETags</cite> object.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.quote_etag">quote_etag</cite> <tt class="func-signature docutils literal"><span class="pre">(etag,</span> <span class="pre">weak=False)</span></tt></dt>
<dd>Quote an etag.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.unquote_etag">unquote_etag</cite> <tt class="func-signature docutils literal"><span class="pre">(etag)</span></tt></dt>
<dd>Unquote a single etag.  Return a <tt class="docutils literal"><span class="pre">(etag,</span> <span class="pre">weak)</span></tt> tuple.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.generate_etag">generate_etag</cite> <tt class="func-signature docutils literal"><span class="pre">(data)</span></tt></dt>
<dd>Generate an etag for some data.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.is_resource_modified">is_resource_modified</cite> <tt class="func-signature docutils literal"><span class="pre">(environ,</span> <span class="pre">etag=None,</span> <span class="pre">data=None,</span> <span class="pre">last_modified=None)</span></tt></dt>
<dd>Convenience method for conditional requests.</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.http.Authorization">Authorization</cite></dt>
<dd><p class="first">Represents an <cite>Authorization</cite> header sent by the client.  You should not
create this kind of object yourself but use it when it&#8217;s returned by the
<cite>parse_authorization_header</cite> function.</p>
<p>This object is a dict subclass and can be altered by setting dict items
but it should be considered immutable as it&#8217;s returned by the client and
not meant for modifications.</p>
<dl>
<dt><cite id="werkzeug.http.WWWAuthenticate.to_header">to_header</cite> <tt class="func-signature docutils literal"><span class="pre">()</span></tt></dt>
<dd>Convert the stored values into a WWW-Authenticate header.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.Authorization.username">username</cite></dt>
<dd>The username transmitted.  This is set for both basic and digest
auth all the time.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.Authorization.password">password</cite></dt>
<dd>When the authentication type is basic this is the password
transmitted by the client, else <cite>None</cite>.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.Authorization.realm">realm</cite></dt>
<dd>This is the server realm send back for digest auth.  For HTTP
digest auth.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.Authorization.nonce">nonce</cite></dt>
<dd>The nonce the server send for digest auth, send back by the client.
A nonce should be unique for every 401 response for HTTP digest
auth.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.Authorization.uri">uri</cite></dt>
<dd>The URI from Request-URI of the Request-Line; duplicated because
proxies are allowed to change the Request-Line in transit.  HTTP
digest auth only.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.Authorization.nc">nc</cite></dt>
<dd>The nonce count value transmitted by clients if a qop-header is
also transmitted.  HTTP digest auth only.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.Authorization.cnonce">cnonce</cite></dt>
<dd>If the server sent a qop-header in the <tt class="docutils literal"><span class="pre">WWW-Authenticate</span></tt>
header, the client has to provide this value for HTTP digest auth.
See the RFC for more details.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.Authorization.response">response</cite></dt>
<dd>A string of 32 hex digits computed as defined in RFC 2617, which
proves that the user knows a password.  Digest auth only.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.Authorization.opaque">opaque</cite></dt>
<dd>The opaque header from the server returned unchanged by the client.
It is recommended that this string be base64 or hexadecimal data.
Digest auth only.</dd>
</dl>
<dl class="last">
<dt><cite id="werkzeug.http.Authorization.qop">qop</cite></dt>
<dd>Indicates what &#8220;quality of protection&#8221; the client has applied to
the message for HTTP digest auth.</dd>
</dl>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.http.WWWAuthenticate">WWWAuthenticate</cite></dt>
<dd><p class="first">Provides simple access to <cite>WWW-Authenticate</cite> headers.</p>
<dl>
<dt><cite id="werkzeug.http.WWWAuthenticate.set_basic">set_basic</cite> <tt class="func-signature docutils literal"><span class="pre">(realm='authentication</span> <span class="pre">required')</span></tt></dt>
<dd>Clear the auth info and enable basic auth.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.WWWAuthenticate.set_digest">set_digest</cite> <tt class="func-signature docutils literal"><span class="pre">(realm,</span> <span class="pre">nonce,</span> <span class="pre">qop=('auth',),</span> <span class="pre">opaque=None,</span> <span class="pre">algorithm=None,</span> <span class="pre">stale=False)</span></tt></dt>
<dd>Clear the auth info and enable digest auth.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.WWWAuthenticate.to_header">to_header</cite> <tt class="func-signature docutils literal"><span class="pre">()</span></tt></dt>
<dd>Convert the stored values into a WWW-Authenticate header.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.WWWAuthenticate.type">type</cite></dt>
<dd>The type of the auth machanism.  HTTP currently specifies
<cite>Basic</cite> and <cite>Digest</cite>.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.WWWAuthenticate.realm">realm</cite></dt>
<dd>A string to be displayed to users so they know which username and
password to use.  This string should contain at least the name of
the host performing the authentication and might additionally
indicate the collection of users who might have access.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.WWWAuthenticate.stale">stale</cite></dt>
<dd>A flag, indicating that the previous request from the client was
rejected because the nonce value was stale.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.WWWAuthenticate.domain">domain</cite></dt>
<dd>A list of URIs that define the protection space.  If a URI is an
absolte path, it is relative to the canonical root URL of the
server being accessed.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.WWWAuthenticate.nonce">nonce</cite></dt>
<dd>A server-specified data string which should be uniquely generated
each time a 401 response is made.  It is recommended that this
string be base64 or hexadecimal data.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.WWWAuthenticate.opaque">opaque</cite></dt>
<dd>A string of data, specified by the server, which should be returned
by the client unchanged in the Authorization header of subsequent
requests with URIs in the same protection space.  It is recommended
that this string be base64 or hexadecimal data.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.WWWAuthenticate.algorithm">algorithm</cite></dt>
<dd>A string indicating a pair of algorithms used to produce the digest
and a checksum.  If this is not present it is assumed to be &#8220;MD5&#8221;.
If the algorithm is not understood, the challenge should be ignored
(and a different one used, if there is more than one).</dd>
</dl>
<dl class="last">
<dt><cite id="werkzeug.http.WWWAuthenticate.qop">qop</cite></dt>
<dd>A set of quality-of-privacy modifies such as auth and auth-int.</dd>
</dl>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.parse_authorization_header">parse_authorization_header</cite> <tt class="func-signature docutils literal"><span class="pre">(value)</span></tt></dt>
<dd>Parse an HTTP basic/digest authorization header transmitted by the web
browser.  The return value is either <cite>None</cite> if the header was invalid or
not given, otherwise an <cite>Authorization</cite> object.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.http.parse_www_authenticate_header">parse_www_authenticate_header</cite> <tt class="func-signature docutils literal"><span class="pre">(value,</span> <span class="pre">on_update=None)</span></tt></dt>
<dd>Parse an HTTP WWW-Authenticate header into a <cite>WWWAuthenticate</cite> object.</dd>
</dl>
<dl>
<dt><cite>HTTP_STATUS_CODES</cite></dt>
<dd>A dict of status code -&gt; default status message pairs.  This is used
by the wrappers and other places where a integer status code is expanded
to a string throughout Werkzeug.</dd>
</dl>
</div>
<div class="section">
<h3 id="url-helpers">URL Helpers</h3>
<dl>
<dt><cite id="werkzeug.utils.url_decode">url_decode</cite> <tt class="func-signature docutils literal"><span class="pre">(s,</span> <span class="pre">charset='utf-8',</span> <span class="pre">decode_keys=False,</span> <span class="pre">include_empty=True)</span></tt></dt>
<dd><p class="first">Parse a querystring and return it as <cite>MultiDict</cite>.  Per default only values
are decoded into unicode strings.  If <cite>decode_keys</cite> is set to <tt class="docutils literal"><span class="pre">True</span></tt> the
same will happen for keys.</p>
<p class="last">Per default a missing value for a key will default to an empty key.  If
you don&#8217;t want that behavior you can set <cite>include_empty</cite> to <cite>False</cite>.</p>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.url_encode">url_encode</cite> <tt class="func-signature docutils literal"><span class="pre">(obj,</span> <span class="pre">charset='utf-8',</span> <span class="pre">encode_keys=False)</span></tt></dt>
<dd>URL encode a dict/<cite>MultiDict</cite>.  If a value is <cite>None</cite> it will not appear in
the result string.  Per default only values are encoded into the target
charset strings.  If <cite>encode_keys</cite> is set to <tt class="docutils literal"><span class="pre">True</span></tt> unicode keys are
supported too.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.url_quote">url_quote</cite> <tt class="func-signature docutils literal"><span class="pre">(s,</span> <span class="pre">charset='utf-8',</span> <span class="pre">safe='/:')</span></tt></dt>
<dd>URL encode a single string with a given encoding.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.url_quote_plus">url_quote_plus</cite> <tt class="func-signature docutils literal"><span class="pre">(s,</span> <span class="pre">charset='utf-8',</span> <span class="pre">safe='')</span></tt></dt>
<dd>URL encode a single string with the given encoding and convert
whitespace to &#8220;+&#8221;.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.url_unquote">url_unquote</cite> <tt class="func-signature docutils literal"><span class="pre">(s,</span> <span class="pre">charset='utf-8')</span></tt></dt>
<dd>URL decode a single string with a given decoding.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.url_unquote_plus">url_unquote_plus</cite> <tt class="func-signature docutils literal"><span class="pre">(s,</span> <span class="pre">charset='utf-8')</span></tt></dt>
<dd>URL decode a single string with the given decoding and decode
a &#8220;+&#8221; to whitespace.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.url_fix">url_fix</cite> <tt class="func-signature docutils literal"><span class="pre">(s,</span> <span class="pre">charset='utf-8')</span></tt></dt>
<dd><p class="first">Sometimes you get an URL by a user that just isn&#8217;t a real URL because
it contains unsafe characters like &#8216; &#8216; and so on.  This function can fix
some of the problems in a similar way browsers handle data entered by the
user:</p>
<div class="syntax"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">url_fix</span><span class="p">(</span><span class="s">u&#39;http://de.wikipedia.org/wiki/Elf (Begriffsklärung)&#39;</span><span class="p">)</span>
<span class="go">&#39;http://de.wikipedia.org/wiki/Elf%20%28Begriffskl%C3%A4rung%29&#39;</span>
</pre></div>
<dl class="last">
<dt>Parameters</dt>
<dd><strong>charset</strong>: The target charset for the URL if the url was given as
unicode string.</dd>
</dl>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.utils.Href">Href</cite></dt>
<dd><p class="first">Implements a callable that constructs URLs with the given base. The
function can be called with any number of positional and keyword
arguments which than are used to assemble the URL.  Works with URLs
and posix paths.</p>
<p>Positional arguments are appended as individual segments to
the path of the URL:</p>
<div class="syntax"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">href</span> <span class="o">=</span> <span class="n">Href</span><span class="p">(</span><span class="s">&#39;/foo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">href</span><span class="p">(</span><span class="s">&#39;bar&#39;</span><span class="p">,</span> <span class="mf">23</span><span class="p">)</span>
<span class="go">&#39;/foo/bar/23&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">href</span><span class="p">(</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="mf">23</span><span class="p">)</span>
<span class="go">&#39;/foo/foo?bar=23&#39;</span>
</pre></div>
<p>If any of the arguments (positional or keyword) evaluates to <cite>None</cite> it
will be skipped.  If no keyword arguments are given the last argument
can be a <cite>dict</cite> or <cite>MultiDict</cite> (or any other dict subclass), otherwise
the keyword arguments are used for the query parameters, cutting off
the first trailing underscore of the parameter name:</p>
<div class="syntax"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">href</span><span class="p">(</span><span class="n">is_</span><span class="o">=</span><span class="mf">42</span><span class="p">)</span>
<span class="go">&#39;/foo?is=42&#39;</span>
</pre></div>
<p>Accessing attributes on the href object creates a new href object with
the attribute name as prefix:</p>
<div class="syntax"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">bar_href</span> <span class="o">=</span> <span class="n">href</span><span class="o">.</span><span class="n">bar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar_href</span><span class="p">(</span><span class="s">&quot;blub&quot;</span><span class="p">)</span>
<span class="go">&#39;/foo/bar/blub&#39;</span>
</pre></div>
</dd>
</dl>
</div>
<div class="section">
<h3 id="html-helpers">HTML Helpers</h3>
<dl>
<dt><cite id="werkzeug.utils.escape">escape</cite> <tt class="func-signature docutils literal"><span class="pre">(s,</span> <span class="pre">quote=None)</span></tt></dt>
<dd><p class="first">Replace special characters &#8220;&amp;&#8221;, &#8220;&lt;&#8221; and &#8220;&gt;&#8221; to HTML-safe sequences.  If the
optional flag <cite>quote</cite> is <cite>True</cite>, the quotation mark character (&#8220;) is also
translated.</p>
<p class="last">There is a special handling for <cite>None</cite> which escapes to an empty string.</p>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.unescape">unescape</cite> <tt class="func-signature docutils literal"><span class="pre">(s)</span></tt></dt>
<dd>The reverse function of <cite>escape</cite>.  This unescapes all the HTML entities,
not only the XML entities inserted by <cite>escape</cite>.</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.utils.HTMLBuilder">HTMLBuilder</cite></dt>
<dd><p class="first">Helper object for HTML generation.</p>
<p>Per default there are two instances of that class.  The <cite>html</cite> one, and
the <cite>xhtml</cite> one for those two dialects.  The class uses keyword parameters
and positional parameters to generate small snippets of HTML.</p>
<p>Keyword parameters are converted to XML/SGML attributes, positional
arguments are used as children.  Because Python accepts positional
arguments before keyword arguments it&#8217;s a good idea to use a list with the
star-syntax for some children:</p>
<div class="syntax"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">html</span><span class="o">.</span><span class="n">p</span><span class="p">(</span><span class="n">class_</span><span class="o">=</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="n">html</span><span class="o">.</span><span class="n">a</span><span class="p">(</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="n">href</span><span class="o">=</span><span class="s">&#39;foo.html&#39;</span><span class="p">),</span> <span class="s">&#39; &#39;</span><span class="p">,</span>
<span class="gp">... </span>                       <span class="n">html</span><span class="o">.</span><span class="n">a</span><span class="p">(</span><span class="s">&#39;bar&#39;</span><span class="p">,</span> <span class="n">href</span><span class="o">=</span><span class="s">&#39;bar.html&#39;</span><span class="p">)])</span>
<span class="go">&#39;&lt;p class=&quot;foo&quot;&gt;&lt;a href=&quot;foo.html&quot;&gt;foo&lt;/a&gt; &lt;a href=&quot;bar.html&quot;&gt;bar&lt;/a&gt;&lt;/p&gt;&#39;</span>
</pre></div>
<p>This class works around some browser limitations and can not be used for
arbitrary SGML/XML generation.  For that purpose lxml and similar
libraries exist.</p>
<p>Calling the builder escapes the string passed:</p>
<div class="syntax"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">html</span><span class="o">.</span><span class="n">p</span><span class="p">(</span><span class="n">html</span><span class="p">(</span><span class="s">&quot;&lt;foo&gt;&quot;</span><span class="p">))</span>
<span class="go">&#39;&lt;p&gt;&amp;lt;foo&amp;gt;&lt;/p&gt;&#39;</span>
</pre></div>
</dd>
</dl>
</div>
<div class="section">
<h3 id="wsgi-helpers">WSGI Helpers</h3>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.utils.ClosingIterator">ClosingIterator</cite></dt>
<dd><p class="first">The WSGI specification requires that all middlewares and gateways respect the
<cite>close</cite> callback of an iterator.  Because it is useful to add another close
action to a returned iterator and adding a custom iterator is a boring task
this class can be used for that:</p>
<div class="syntax"><pre><span class="k">return</span> <span class="n">ClosingIterator</span><span class="p">(</span><span class="n">app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">),</span> <span class="p">[</span><span class="n">cleanup_session</span><span class="p">,</span>
                                                      <span class="n">cleanup_locals</span><span class="p">])</span>
</pre></div>
<p>If there is just one close function it can be bassed instead of the list.</p>
<p>A closing iterator is non needed if the application uses response objects
and finishes the processing if the resonse is started:</p>
<div class="syntax"><pre><span class="k">try</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">response</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">cleanup_session</span><span class="p">()</span>
    <span class="n">cleanup_locals</span><span class="p">()</span>
</pre></div>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.utils.SharedDataMiddleware">SharedDataMiddleware</cite></dt>
<dd><p class="first">A WSGI middleware that provides static content for development
environments or simple server setups. Usage is quite simple:</p>
<div class="syntax"><pre><span class="k">import</span> <span class="nn">os</span>
<span class="k">from</span> <span class="nn">werkzeug</span> <span class="k">import</span> <span class="n">SharedDataMiddleware</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">SharedDataMiddleware</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="p">{</span>
    <span class="s">&#39;/shared&#39;</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">__file__</span><span class="p">),</span> <span class="s">&#39;shared&#39;</span><span class="p">)</span>
<span class="p">})</span>
</pre></div>
<p>The contents of the folder <tt class="docutils literal"><span class="pre">./shared</span></tt> will now be available on
<tt class="docutils literal"><span class="pre">http://example.com/shared/</span></tt>.  This is pretty useful during development
because a standalone media server is not required.  One can also mount
files on the root folder and still continue to use the application because
the shared data middleware forwards all unhandled requests to the
application, even if the requests are below one of the shared folders.</p>
<p>If <cite>pkg_resources</cite> is available you can also tell the middleware to serve
files from package data:</p>
<div class="syntax"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">SharedDataMiddleware</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="p">{</span>
    <span class="s">&#39;/shared&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;myapplication&#39;</span><span class="p">,</span> <span class="s">&#39;shared_files&#39;</span><span class="p">)</span>
<span class="p">})</span>
</pre></div>
<p class="last">This will then serve the <tt class="docutils literal"><span class="pre">shared_files</span></tt> folder in the <cite>myapplication</cite>
python package.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.utils.DispatcherMiddleware">DispatcherMiddleware</cite></dt>
<dd><p class="first">Allows one to mount middlewares or application in a WSGI application.
This is useful if you want to combine multiple WSGI applications:</p>
<div class="syntax"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">DispatcherMiddleware</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="p">{</span>
    <span class="s">&#39;/app2&#39;</span><span class="p">:</span>        <span class="n">app2</span><span class="p">,</span>
    <span class="s">&#39;/app3&#39;</span><span class="p">:</span>        <span class="n">app3</span>
<span class="p">})</span>
</pre></div>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.utils.FileStorage">FileStorage</cite></dt>
<dd><p class="first">The <cite>FileStorage</cite> object is a thin wrapper over incoming files.  It is
used by the request object to represent uploaded files.  All the
attributes of the wrapper stream are proxied by the file storage so
it&#8217;s possible to do <tt class="docutils literal"><span class="pre">storage.read()</span></tt> instead of the long form
<tt class="docutils literal"><span class="pre">storage.stream.read()</span></tt>.</p>
<dl>
<dt><cite>name</cite></dt>
<dd>The name of the form field which represents the data.</dd>
<dt><cite>filename</cite></dt>
<dd>The incoming filename.</dd>
<dt><cite>content_type</cite></dt>
<dd>The mimetype of the file.  E.g. <tt class="docutils literal"><span class="pre">'text/html'</span></tt>.</dd>
<dt><cite>content_length / len()</cite></dt>
<dd>The expected length of the file.</dd>
<dt><cite>stream</cite></dt>
<dd>Gives you access to the underlaying stream.  Note that the exact
methods of this stream and its type is not strictly specified.  In
most situations it will be a <cite>TemporaryFile</cite> object.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.FileStorage.__init__">__init__</cite> <tt class="func-signature docutils literal"><span class="pre">(stream=None,</span> <span class="pre">filename=None,</span> <span class="pre">name=None,</span> <span class="pre">content_type='application/octet-stream',</span> <span class="pre">content_length=-1)</span></tt></dt>
<dd><p class="first">Creates a new <cite>FileStorage</cite> object.  The constructor looked different
for Werkzeug 0.1 but there the object was only used internally.</p>
<dl class="last">
<dt>Parameters</dt>
<dd><p class="first"><strong>stream</strong>: the input stream for uploaded file.  Usually this
points to a temporary file.</p>
<p><strong>filename</strong>: The filename of the file on the client.</p>
<p><strong>name</strong>: the name of the form field</p>
<p><strong>content_type</strong>: the content type of the file</p>
<p class="last"><strong>content_length</strong>: the content length of the file.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="last">
<dt><cite id="werkzeug.utils.FileStorage.save">save</cite> <tt class="func-signature docutils literal"><span class="pre">(dst,</span> <span class="pre">buffer_size=16384)</span></tt></dt>
<dd>Save the file to a destination path or file object.  If the
destination is a file object you have to close it yourself after the
call.  The buffer size is the number of bytes held in the memory
during the copy process.  It defaults to 16KB.</dd>
</dl>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.get_host">get_host</cite> <tt class="func-signature docutils literal"><span class="pre">(environ)</span></tt></dt>
<dd>Return the real host for the given WSGI enviornment.  This takes care
of the <cite>X-Forwarded-Host</cite> header.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.get_current_url">get_current_url</cite> <tt class="func-signature docutils literal"><span class="pre">(environ,</span> <span class="pre">root_only=False,</span> <span class="pre">strip_querystring=False,</span> <span class="pre">host_only=False)</span></tt></dt>
<dd><p class="first">A handy helper function that recreates the full URL for the current
request or parts of it.  Here an example:</p>
<div class="syntax"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">env</span> <span class="o">=</span> <span class="n">create_environ</span><span class="p">(</span><span class="s">&quot;/?param=foo&quot;</span><span class="p">,</span> <span class="s">&quot;http://localhost/script&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_current_url</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
<span class="go">&#39;http://localhost/script/?param=foo&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_current_url</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">root_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">&#39;http://localhost/script/&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_current_url</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">host_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">&#39;http://localhost/&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_current_url</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">strip_querystring</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">&#39;http://localhost/script/&#39;</span>
</pre></div>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.responder">responder</cite> <tt class="func-signature docutils literal"><span class="pre">(f)</span></tt></dt>
<dd><p class="first">Marks a function as responder.  Decorate a function with it and it
will automatically call the return value as WSGI application.</p>
<p>Example:</p>
<div class="syntax"><pre><span class="nd">@responder</span>
<span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s">&#39;Hello World!&#39;</span><span class="p">)</span>
</pre></div>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.create_environ">create_environ</cite> <tt class="func-signature docutils literal"><span class="pre">(path='/',</span> <span class="pre">base_url=None,</span> <span class="pre">query_string=None,</span> <span class="pre">method='GET',</span> <span class="pre">input_stream=None,</span> <span class="pre">content_type=None,</span> <span class="pre">content_length=0,</span> <span class="pre">errors_stream=None,</span> <span class="pre">multithread=False,</span> <span class="pre">multiprocess=False,</span> <span class="pre">run_once=False)</span></tt></dt>
<dd><p class="first">Create a new WSGI environ dict based on the values passed.  The first
parameter should be the path of the request which defaults to &#8216;/&#8217;.
The second one can either be a absolute path (in that case the URL
host is localhost:80) or a full path to the request with scheme,
netloc port and the path to the script.</p>
<p>If the <cite>path</cite> contains a query string it will be used, even if the
<cite>query_string</cite> parameter was given.  If it does not contain one
the <cite>query_string</cite> parameter is used as querystring.  In that case
it can either be a dict, MultiDict or string.</p>
<p>The following options exist:</p>
<dl class="last">
<dt><cite>method</cite></dt>
<dd>The request method.  Defaults to <cite>GET</cite></dd>
<dt><cite>input_stream</cite></dt>
<dd>The input stream.  Defaults to an empty read only stream.</dd>
<dt><cite>content_type</cite></dt>
<dd>The content type for this request.  Default is an empty content
type.</dd>
<dt><cite>content_length</cite></dt>
<dd>The value for the content length header.  Defaults to 0.</dd>
<dt><cite>errors_stream</cite></dt>
<dd>The wsgi.errors stream.  Defaults to <cite>sys.stderr</cite>.</dd>
<dt><cite>multithread</cite></dt>
<dd>The multithreaded flag for the WSGI Environment.  Defaults to <cite>False</cite>.</dd>
<dt><cite>multiprocess</cite></dt>
<dd>The multiprocess flag for the WSGI Environment.  Defaults to <cite>False</cite>.</dd>
<dt><cite>run_once</cite></dt>
<dd>The run_once flag for the WSGI Environment.  Defaults to <cite>False</cite>.</dd>
</dl>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.run_wsgi_app">run_wsgi_app</cite> <tt class="func-signature docutils literal"><span class="pre">(app,</span> <span class="pre">environ,</span> <span class="pre">buffered=False)</span></tt></dt>
<dd><p class="first">Return a tuple in the form (app_iter, status, headers) of the application
output.  This works best if you pass it an application that returns a
iterator all the time.</p>
<p>Sometimes applications may use the <cite>write()</cite> callable returned
by the <cite>start_response</cite> function.  This tries to resolve such edge
cases automatically.  But if you don&#8217;t get the expected output you
should set <cite>buffered</cite> to <cite>True</cite> which enforces buffering.</p>
<p class="last">If passed an invalid WSGI application the behavior of this function is
undefined.  Never pass non-conforming WSGI applications to this function.</p>
</dd>
</dl>
</div>
<div class="section">
<h3 id="helper-functions">Helper Functions</h3>
<dl>
<dt><cite id="werkzeug.utils.cached_property">cached_property</cite> <tt class="func-signature docutils literal"><span class="pre">(func,</span> <span class="pre">name=None,</span> <span class="pre">doc=None)</span></tt></dt>
<dd><p class="first">A decorator that converts a function into a lazy property. The
function wrapped is called the first time to retrieve the result
and than that calculated result is used the next time you access
the value:</p>
<div class="syntax"><pre><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># calculate something important here</span>
        <span class="k">return</span> <span class="mf">42</span>
</pre></div>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.environ_property">environ_property</cite> <tt class="func-signature docutils literal"><span class="pre">(name,</span> <span class="pre">default=None,</span> <span class="pre">load_func=None,</span> <span class="pre">dump_func=None,</span> <span class="pre">read_only=False,</span> <span class="pre">doc=None)</span></tt></dt>
<dd><p class="first">Maps request attributes to environment variables. This works not only
for the Werzeug request object, but also any other class with an
environ attribute:</p>
<div class="syntax"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">test_p</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">environ</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&#39;test&#39;</span><span class="p">:</span> <span class="s">&#39;test&#39;</span> <span class="p">}</span>
<span class="gp">... </span>    <span class="n">test</span> <span class="o">=</span> <span class="n">environ_property</span><span class="p">(</span><span class="s">&#39;test&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">test_p</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span><span class="o">.</span><span class="n">test</span>
<span class="go">test</span>
</pre></div>
<p>If you pass it a second value it&#8217;s used as default if the key does not
exist, the third one can be a converter that takes a value and converts
it.  If it raises <cite>ValueError</cite> or <cite>TypeError</cite> the default value is used.
If no default value is provided <cite>None</cite> is used.</p>
<p class="last">Per default the property works in two directions, but if you set
<cite>read_only</cite> to False it will block set/delete.</p>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.header_property">header_property</cite> <tt class="func-signature docutils literal"><span class="pre">(name,</span> <span class="pre">default=None,</span> <span class="pre">load_func=None,</span> <span class="pre">dump_func=None,</span> <span class="pre">read_only=False,</span> <span class="pre">doc=None)</span></tt></dt>
<dd>Like <cite>environ_property</cite> but for headers.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.cookie_date">cookie_date</cite> <tt class="func-signature docutils literal"><span class="pre">(expires=None,</span> <span class="pre">_date_delim='-')</span></tt></dt>
<dd><p class="first">Formats the time to ensure compatibility with Netscape&#8217;s cookie standard.</p>
<p>Accepts a floating point number expressed in seconds since the epoc in, a
datetime object or a timetuple.  All times in UTC.  The <cite>parse_date</cite>
function in <cite>werkzeug.http</cite> can be used to parse such a date.</p>
<p class="last">Outputs a string in the format <tt class="docutils literal"><span class="pre">Wdy,</span> <span class="pre">DD-Mon-YYYY</span> <span class="pre">HH:MM:SS</span> <span class="pre">GMT</span></tt>.</p>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.http_date">http_date</cite> <tt class="func-signature docutils literal"><span class="pre">(timestamp=None)</span></tt></dt>
<dd><p class="first">Formats the time to match the RFC1123 date format.</p>
<p>Accepts a floating point number expressed in seconds since the epoc in, a
datetime object or a timetuple.  All times in UTC.  The <cite>parse_date</cite>
function in <cite>werkzeug.http</cite> can be used to parse such a date.</p>
<p class="last">Outputs a string in the format <tt class="docutils literal"><span class="pre">Wdy,</span> <span class="pre">DD</span> <span class="pre">Mon</span> <span class="pre">YYYY</span> <span class="pre">HH:MM:SS</span> <span class="pre">GMT</span></tt>.</p>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.parse_cookie">parse_cookie</cite> <tt class="func-signature docutils literal"><span class="pre">(header,</span> <span class="pre">charset='utf-8')</span></tt></dt>
<dd>Parse a cookie.  Either from a string or WSGI environ.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.dump_cookie">dump_cookie</cite> <tt class="func-signature docutils literal"><span class="pre">(key,</span> <span class="pre">value='',</span> <span class="pre">max_age=None,</span> <span class="pre">expires=None,</span> <span class="pre">path='/',</span> <span class="pre">domain=None,</span> <span class="pre">secure=None,</span> <span class="pre">httponly=False,</span> <span class="pre">charset='utf-8',</span> <span class="pre">sync_expires=True)</span></tt></dt>
<dd><p class="first">Creates a new Set-Cookie header without the <tt class="docutils literal"><span class="pre">Set-Cookie</span></tt> prefix
The parameters are the same as in the cookie Morsel object in the
Python standard library but it accepts unicode data too.</p>
<dl class="last">
<dt>Parameters</dt>
<dd><p class="first"><strong>max_age</strong>: should be a number of seconds, or <cite>None</cite> (default) if
the cookie should last only as long as the client&#8217;s
browser session.  Additionally <cite>timedelta</cite> objects
are accepted too.</p>
<p><strong>expires</strong>: should be a <cite>datetime</cite> object or unix timestamp.</p>
<p><strong>path</strong>: limits the cookie to a given path, per default it will
span the whole domain.</p>
<p><strong>domain</strong>: Use this if you want to set a cross-domain cookie. For
example, <tt class="docutils literal"><span class="pre">domain=&quot;.example.com&quot;</span></tt> will set a cookie
that is readable by the domain <tt class="docutils literal"><span class="pre">www.example.com</span></tt>,
<tt class="docutils literal"><span class="pre">foo.example.com</span></tt> etc. Otherwise, a cookie will only
be readable by the domain that set it.</p>
<p><strong>secure</strong>: The cookie will only be available via HTTPS</p>
<p><strong>httponly</strong>: disallow JavaScript to access the cookie.  This is an
extension to the cookie standard and probably not
supported by all browsers.</p>
<p><strong>charset</strong>: the encoding for unicode values.</p>
<p class="last"><strong>sync_expires</strong>: automatically set expires if max_age is defined
but expires not.</p>
</dd>
</dl>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.redirect">redirect</cite> <tt class="func-signature docutils literal"><span class="pre">(location,</span> <span class="pre">code=302)</span></tt></dt>
<dd>Return a response object (a WSGI application) that, if called, redirects
the client to the target location.  Supported codes are 301, 302, 303,
305, and 307.  300 is not supported because it&#8217;s not a real redirect and
304 because it&#8217;s the answer for a request with a request with defined
If-Modified-Since headers.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.append_slash_redirect">append_slash_redirect</cite> <tt class="func-signature docutils literal"><span class="pre">(environ,</span> <span class="pre">code=301)</span></tt></dt>
<dd>Redirect to the same URL but with a slash appended.  The behavior
of this function is undefined if the path ends with a slash already.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.import_string">import_string</cite> <tt class="func-signature docutils literal"><span class="pre">(import_name,</span> <span class="pre">silent=False)</span></tt></dt>
<dd><p class="first">Imports an object based on a string.  This use useful if you want to use
import paths as endpoints or something similar.  An import path can
be specified either in dotted notation (<tt class="docutils literal"><span class="pre">xml.sax.saxutils.escape</span></tt>)
or with a colon as object delimiter (<tt class="docutils literal"><span class="pre">xml.sax.saxutils:escape</span></tt>).</p>
<p>If the <cite>silent</cite> is True the return value will be <cite>None</cite> if the import
fails.</p>
<p class="last"><strong>returns</strong>: imported object</p>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.utils.find_modules">find_modules</cite> <tt class="func-signature docutils literal"><span class="pre">(import_path,</span> <span class="pre">include_packages=False,</span> <span class="pre">recursive=False)</span></tt></dt>
<dd><p class="first">Find all the modules below a package.  This can be useful to automatically
import all views / controllers so that their metaclasses / function
decorators have a chance to register themselves on the application.</p>
<p>Packages are not returned unless <cite>include_packages</cite> is <cite>True</cite>.  This can
also recursively list modules but in that case it will import all the
packages to get the correct load path of that module.</p>
<p class="last"><strong>returns</strong>: generator</p>
</dd>
</dl>
<dl>
<dt><cite id="werkzeug.testapp.test_app">test_app</cite> <tt class="func-signature docutils literal"><span class="pre">(environ,</span> <span class="pre">start_response)</span></tt></dt>
<dd>Simple test application that dumps the environment.</dd>
</dl>
</div>

      <div style="clear:both"></div>
    </div>
    <div class="footer">
      Werkzeug is a <a href="http://pocoo.org/">Pocoo</a> project licensed under the
      BSD license.
    </div>
  </div>
</body>
</html>